#!/usr/bin/perl
# A part of steam-linux-workarounds
# Copyright (C) Eskild Hustvedt 2016
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
use 5.020;
use Getopt::Long;
use File::Basename qw(basename dirname);
use JSON;
use Cwd qw(realpath);

# Purpose: Read an entire file into a scalar
sub slurp
{
    my $file = shift;
    local $/ = undef;
    open(my $i,'<',$file);
    my $content = <$i>;
    close($i);
    return $content;
}

# Purpose: Retrieve a list of all installed games
# FIXME: Does not support listing games not in the main library.
sub listInstalledGames
{
    my @steamPaths = ($ENV{HOME}.'/.steam/steam/');
    my %games;
    foreach my $dir (@steamPaths)
    {
        foreach my $entry (glob($dir.'/steamapps/common/*'))
        {
            if (-d $entry)
            {
                $games{ basename($entry) } = $entry;
            }
        }
    }
    return \%games;
}

# Purpose: Load all patch metadata and return it in a hash
sub loadPatchMetadata
{
    my %patches;
    foreach my $patch (glob('./patches/*.json'))
    {
        my $fileBase = basename($patch);
        $fileBase =~ s/\.json$//;
        my $data = decode_json(slurp($patch));
        $patches{ $data->{directoryName} } = {
            meta => $data,
            basename => $fileBase,
        };
    }
    return \%patches;
}

# Purpose: Execute a single patch
sub executePatch
{
    my $patch = shift;
    my $patchRoot = shift;
    my $mode = shift;
    $mode //= 'patch';
    my $prevDir = realpath('.');
    if (-e './patches/'.$patch.'.sh')
    {
        $| = 1;
        print $mode eq 'reverse' ? 'Reversing ' : 'Applying ';
        print "patch to $patch...";
        my $patchScript = realpath('./patches/'.$patch.'.sh');
        my $shlib = realpath('./helpers/shlib.sh');
        my $action = 'performPatch';
        if ($mode eq 'reverse')
        {
            $action = 'undoPatch';
        }
        system('bash','-c','cd "$1";source "$2"; source "$3";'.$action,'patch-runner-sh',$patchRoot,$shlib,$patchScript);
        print "done\n";
    }
    else
    {
        die('Failed to locate script for '.$patch."\n");
    }
}

# Purpose: Print formatted --help output
# Usage: printHelp('-shortoption', '--longoption', 'description');
#  Description will be reformatted to fit within a normal terminal
sub printHelp
{
    # The short option
    my $short = shift,
    # The long option
    my $long = shift;
    # The description
    my $desc = shift;
    # The generated description that will be printed in the end
    my $GeneratedDesc;
    # The current line of the description
    my $currdesc = '';
    # The maximum length any line can be
    my $maxlen = 80;
    # The length the options take up
    my $optionlen = 23;
    # Check if the short/long are LONGER than optionlen, if so, we need
    # to do some additional magic to take up only $maxlen.
    # The +1 here is because we always add a space between them, no matter what
    if ((length($short) + length($long) + 1) > $optionlen)
    {
        $optionlen = length($short) + length($long) + 1;
    }
    # Split the description into lines
    foreach my $part (split(' ',$desc))
    {
        if(defined $GeneratedDesc)
        {
            if ((length($currdesc) + length($part) + 1 + 24) > $maxlen)
            {
                $GeneratedDesc .= "\n";
                $currdesc = '';
            }
            else
            {
                $currdesc .= ' ';
                $GeneratedDesc .= ' ';
            }
        }
        $currdesc .= $part;
        $GeneratedDesc .= $part;
    }
    # Something went wrong
    pDie('Option mismatch') if not $GeneratedDesc;
    # Print it all
    foreach my $description (split(/\n/,$GeneratedDesc))
    {
        printf "%-4s %-22s %s\n", $short,$long,$description;
        # Set short and long to '' to ensure we don't print the options twice
        $short = '';$long = '';
    }
    # Succeed
    return 1;
}

# Purpose: Output usage information
sub usage
{
    say "USAGE: apply-patches OPTIONS? game1, game2 ..";
    say "";
    printHelp('','--all','Apply all patches if requested');
    printHelp('','--undo','Undo a patch instead of applying it');
    printHelp('','--help','Print this help information');
    printHelp('','--list','List all installed games that have patches');
    exit(shift);
}

# Purpose: Main entry point
sub main
{
    chdir( dirname(realpath($0)) );
    if ( ! -e './patches')
    {
        die('Failed to locate patches');
    }

    my $action = 'patch';
    my $allowAll = 0;

    Getopt::Long::Configure('no_ignore_case','bundling');
    GetOptions(
        'help' => sub {
            usage(0);
        },
        'undo' => sub {
            $action = 'reverse';
        },
        'list' => sub {
            $action = 'list';
            $allowAll = 1;
        },
        'all' => sub
        {
            $allowAll = 1;
        },
    );

    my $installedGames = listInstalledGames();
    my $patches = loadPatchMetadata();

    my @performOnGames = @ARGV;
    if (!@performOnGames || $action eq 'list')
    {
        if (!$allowAll)
        {
            usage(0);
        }
        @performOnGames = keys %{$patches};
    }

    if ($action eq 'list')
    {
        say 'Installed games with available patches:';
    }
    foreach my $patchGame (@performOnGames)
    {
        if (!$installedGames->{$patchGame})
        {
            if (!$allowAll)
            {
                say "$patchGame: does not appear to be installed";
            }
            next;
        }
        if (!$patches->{$patchGame})
        {
            say "$patchGame: has no patches";
            next;
        }
        if ($installedGames->{$patchGame})
        {
            if ($action eq 'list')
            {
                say $patchGame;
            }
            else
            {
                executePatch($patches->{$patchGame}->{basename},$installedGames->{$patchGame},$action);
            }
        }
    }
}

main();
